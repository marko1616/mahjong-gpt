from dataclasses import dataclass
from typing import Dict, Optional, Tuple
import random

from mahjong.shanten import Shanten
from mahjong.hand_calculating.hand import HandCalculator

from .constants import (
    ACTIONS_PER_SEAT,
    NUM_SEATS,
    DISCARD_MIN,
    DISCARD_MAX,
    CHI_UP,
    CHI_MID,
    CHI_DOWN,
    PON,
    KAN_OPEN,
    KAN_ADD,
    KAN_CLOSED,
    RIICHI,
    RON,
    TSUMO,
    PASS,
    PLAYER_TOKENS,
)
from .event_bus import EventBus
from .reward_config import RewardConfig
from .tiles import tile34_to_str
from .wall import MahjongWall
from .player import MahjongPlayer
from .tokens import TokenList


@dataclass(frozen=True)
class PendingClaim:
    """Represents a claim opportunity generated by a discard."""

    claimant: int
    action: int
    from_seat: int
    discard_tile34: int
    chi_sequence: Optional[Tuple[int, int, int]] = None
    score_result: Optional[object] = None


class MahjongEnv:
    """
    Multi-seat Mahjong environment.

    Action space:
        - action id in [0..45]
    """

    def __init__(
        self, seed: Optional[int] = None, reward: Optional[RewardConfig] = None
    ) -> None:
        self.rng = random.Random(seed)
        self.bus = EventBus()
        self.reward = reward or RewardConfig()

        self.shanten_calc = Shanten()
        self.score_calc = HandCalculator()

        self.wall = MahjongWall(self.rng)
        self.players: list[MahjongPlayer] = [
            MahjongPlayer(i, self.bus) for i in range(NUM_SEATS)
        ]

        self.done: bool = False
        self.pending_done: bool = False
        self.seat_now: int = 0
        self.kan_count: int = 0
        self.claiming_from: int = 0

        self.pending_claims: list[PendingClaim] = []
        self.history_tokens: TokenList = TokenList()
        self.force_discard_only: bool = False

    def reset(self, seed: Optional[int] = None) -> Tuple[Dict, float, bool, Dict]:
        """
        Reset the game state and deal initial tiles.

        Returns:
            Tuple of (observation, reward, done, info).
        """
        self.rng = random.Random(seed)

        self.done = False
        self.pending_done = False
        self.seat_now = 0
        self.kan_count = 0
        self.claiming_from = 0
        self.pending_claims = []
        self.history_tokens = TokenList()
        self.force_discard_only = False

        self.wall.reset()
        for p in self.players:
            p.reset()

        for _ in range(13):
            for seat in range(NUM_SEATS):
                self.players[seat].draw(self.wall.draw())

        self.players[0].draw(self.wall.draw())

        obs, info = self._build_obs_and_info(reward_update=0.0)
        return obs, 0.0, self.done, info

    def step(self, action: int) -> Tuple[Dict, float, bool, Dict]:
        """
        Execute one action step.

        Args:
            action: Action id in [0..45].

        Returns:
            Tuple of (observation, reward, done, info).

        Raises:
            ValueError: If action is illegal for current seat.
        """
        if self.done:
            return (
                self._build_obs_and_info(reward_update=0.0)[0],
                0.0,
                True,
                self._build_obs_and_info(0.0)[1],
            )

        self.history_tokens.append(action)

        reward = 0.0
        reward_update = 0.0

        if self.pending_claims:
            reward = self._handle_claim_phase(action)
            obs, info = self._build_obs_and_info(reward_update=0.0)
            return obs, reward, self.done, info

        if DISCARD_MIN <= action <= DISCARD_MAX:
            discard_tile34 = action
            reward_update = self._apply_reward_shaping_before_discard(self.seat_now)
            self._do_discard(self.seat_now, discard_tile34)
            self._generate_claims_from_discard(
                discarder=self.seat_now, tile34=discard_tile34
            )

            if self.pending_claims:
                self.seat_now = self.pending_claims[0].claimant
                self.force_discard_only = False
            else:
                self._advance_to_next_draw()

            obs, info = self._build_obs_and_info(reward_update=reward_update)
            return obs, reward, self.done, info

        if action == TSUMO:
            reward = self._handle_tsumo()
            obs, info = self._build_obs_and_info(reward_update=0.0)
            return obs, reward, self.done, info

        if action == RIICHI:
            reward = self._handle_riichi()
            self.force_discard_only = True
            obs, info = self._build_obs_and_info(reward_update=0.0)
            return obs, reward, self.done, info

        if action in (KAN_CLOSED, KAN_ADD):
            reward = self._handle_self_kan(action)
            obs, info = self._build_obs_and_info(reward_update=0.0)
            return obs, reward, self.done, info

        if action == PASS:
            obs, info = self._build_obs_and_info(reward_update=0.0)
            return obs, 0.0, self.done, info

        raise ValueError(f"unsupported action in turn phase: {action}")

    def _handle_claim_phase(self, action: int) -> float:
        """Handle claim decisions for current claimant."""
        claimant = self.seat_now
        offered = [c for c in self.pending_claims if c.claimant == claimant]

        if action == PASS:
            self.pending_claims = [
                c for c in self.pending_claims if c.claimant != claimant
            ]
            self._resolve_claim_queue_progress()
            return 0.0

        chosen = None
        for c in offered:
            if c.action == action:
                chosen = c
                break
        if chosen is None:
            raise ValueError("chosen action is not among offered claims")

        self.pending_claims = [c for c in self.pending_claims if c.claimant != claimant]

        if action == RON:
            self.pending_done = True
            self.bus.publish(
                "win_ron",
                seat=claimant,
                from_seat=chosen.from_seat,
                tile34=chosen.discard_tile34,
            )
            score_main = float(chosen.score_result.cost["main"])
            reward = score_main * self.reward.score_weight

            self._resolve_claim_queue_progress()
            if self.pending_done and not any(
                c.action == RON for c in self.pending_claims
            ):
                self.done = True
            return reward

        discarder = chosen.from_seat
        discard_tile = chosen.discard_tile34
        self.players[discarder].pop_last_discard_for_call(discard_tile)

        if action in (CHI_UP, CHI_MID, CHI_DOWN):
            seq = chosen.chi_sequence
            assert seq is not None
            a, b = [t for t in seq if t != discard_tile]
            self.players[claimant].hand.remove(a, 1)
            self.players[claimant].hand.remove(b, 1)
            self.players[claimant].hand.add_open_meld_chi(seq)
            return float(
                self.reward.reward_open_tanyao
            ) + self._after_meld_requires_discard(claimant)

        if action == PON:
            self.players[claimant].hand.add_open_meld_pon(discard_tile)
            self.players[claimant].hand.remove(discard_tile, 2)
            return float(
                self.reward.reward_open_tanyao
            ) + self._after_meld_requires_discard(claimant)

        if action == KAN_OPEN:
            self.kan_count += 1
            self.players[claimant].hand.remove(discard_tile, 3)
            self.players[claimant].hand.add_open_meld_kan(discard_tile)
            rin = self.wall.draw_rinshan()
            self.players[claimant].draw(rin)
            return float(
                self.reward.reward_open_tanyao
            ) + self._after_meld_requires_discard(claimant)

        raise ValueError(f"unexpected claim action: {action}")

    def _after_meld_requires_discard(self, seat: int) -> float:
        """Set state for mandatory discard after a meld call."""
        self.seat_now = seat
        self.force_discard_only = True
        self.pending_claims = []
        return 0.0

    def _resolve_claim_queue_progress(self) -> None:
        """Advance claim resolution or restore normal flow."""
        if self.pending_claims:
            self.seat_now = self.pending_claims[0].claimant
            self.force_discard_only = False
            return

        self.seat_now = self.claiming_from
        self.force_discard_only = False
        self._advance_to_next_draw()

    def _handle_tsumo(self) -> float:
        """Process a tsumo (self-draw win) declaration."""
        seat = self.seat_now
        p = self.players[seat]

        if p.hand.shanten(self.shanten_calc) != -1:
            raise ValueError("tsumo chosen but not a winning hand")

        last = p.state.last_drawn
        if last is None:
            raise RuntimeError("no last drawn tile for tsumo")

        result = p.hand.estimate_value(
            calculator=self.score_calc,
            win_tile34=last,
            melds=p.hand.melds,
            dora_indicators_136=self.wall.dora_indicators_136(
                kan_count=self.kan_count,
                end=True,
                riichi=p.state.riichi,
            ),
            is_riichi=p.state.riichi,
            has_open_tanyao=p.hand.has_open_tanyao,
        )
        if result.error:
            if result.error == "no_yaku":
                self.done = True
                self.bus.publish("win_tsumo", seat=seat, tile34=last)
                return self.reward.reward_no_yaku
            raise ValueError(f"tsumo has error: {result.error}")

        self.done = True
        self.bus.publish("win_tsumo", seat=seat, tile34=last)
        return float(result.cost["main"]) * self.reward.score_weight

    def _handle_riichi(self) -> float:
        """Process a riichi declaration."""
        seat = self.seat_now
        p = self.players[seat]

        if p.state.riichi:
            raise ValueError("already riichi")
        if p.hand.melds:
            raise ValueError("riichi requires closed hand")
        if p.hand.shanten(self.shanten_calc) != 0:
            raise ValueError("riichi requires tenpai (shanten==0)")

        p.state.riichi = True
        p.state.riichi_lock = False
        self.bus.publish("riichi_declared", seat=seat)
        return float(self.reward.reward_riichi)

    def _handle_self_kan(self, action: int) -> float:
        """
        Process ankan (closed kan) or kakan (added kan).

        Note:
            When multiple candidates exist, the smallest tile34 index is chosen.
        """
        seat = self.seat_now
        p = self.players[seat]

        if action == KAN_CLOSED:
            candidates = [i for i, c in enumerate(p.hand.as_tile34()) if c == 4]
            if not candidates:
                raise ValueError("ankan chosen but no 4-of-a-kind in hand")
            tile = candidates[0]
            self.kan_count += 1
            p.hand.remove(tile, 4)
            p.hand.add_closed_kan(tile)
            rin = self.wall.draw_rinshan()
            p.draw(rin)
            self.force_discard_only = True
            return 0.0

        if action == KAN_ADD:
            counts = p.hand.as_tile34()
            for t in range(34):
                if counts[t] >= 1:
                    try:
                        if not p.hand.has_open_pon(t):
                            continue
                        p.hand.remove(t, 1)
                        p.hand.upgrade_pon_to_kan(t)
                        self.kan_count += 1
                        rin = self.wall.draw_rinshan()
                        p.draw(rin)
                        self.force_discard_only = True
                        return 0.0
                    except Exception:
                        if counts[t] >= 1 and p.hand.count(t) == counts[t] - 1:
                            p.hand.add(t, 1)
                        continue

            raise ValueError("kakan chosen but no valid pon+drawn tile to upgrade")

        raise ValueError("unknown kan action")

    def _do_discard(self, seat: int, tile34: int) -> None:
        """Execute a discard action."""
        p = self.players[seat]

        if p.state.riichi and p.state.riichi_lock:
            if p.state.last_drawn is None or tile34 != p.state.last_drawn:
                raise ValueError("riichi lock: must discard the drawn tile")

        p.discard(tile34)

        if p.state.riichi and not p.state.riichi_lock:
            p.state.riichi_lock = True

        self.claiming_from = seat
        self.force_discard_only = False

    def _generate_claims_from_discard(self, discarder: int, tile34: int) -> None:
        """Generate claim opportunities (ron/kan/pon/chi) for other players."""
        self.pending_claims = []

        for seat in range(NUM_SEATS):
            if seat == discarder:
                continue

            claimant = self.players[seat]

            tmp = claimant.hand.copy()
            tmp.add(tile34, 1)
            if tmp.shanten(self.shanten_calc) == -1:
                result = tmp.estimate_value(
                    calculator=self.score_calc,
                    win_tile34=tile34,
                    melds=claimant.hand.melds,
                    dora_indicators_136=self.wall.dora_indicators_136(
                        kan_count=self.kan_count,
                        end=True,
                        riichi=self.players[discarder].state.riichi,
                    ),
                    is_riichi=self.players[discarder].state.riichi,
                    has_open_tanyao=self.players[discarder].hand.has_open_tanyao,
                )
                if not result.error:
                    self.pending_claims.append(
                        PendingClaim(
                            claimant=seat,
                            action=RON,
                            from_seat=discarder,
                            discard_tile34=tile34,
                            score_result=result,
                        )
                    )
                elif result.error == self.score_calc.ERR_NO_YAKU:
                    self.bus.publish(
                        "no_yaku_encountered",
                        discarder=discarder,
                        claimant=seat,
                        tile34=tile34,
                    )

            if claimant.state.riichi:
                continue

            cnt = claimant.hand.count(tile34)

            if cnt == 3:
                self.pending_claims.append(
                    PendingClaim(
                        claimant=seat,
                        action=KAN_OPEN,
                        from_seat=discarder,
                        discard_tile34=tile34,
                    )
                )
            if cnt >= 2:
                self.pending_claims.append(
                    PendingClaim(
                        claimant=seat,
                        action=PON,
                        from_seat=discarder,
                        discard_tile34=tile34,
                    )
                )

            left_seat = (discarder + 1) % NUM_SEATS
            if seat == left_seat:
                for opt in claimant.hand.possible_chi(tile34):
                    self.pending_claims.append(
                        PendingClaim(
                            claimant=seat,
                            action=opt.action,
                            from_seat=discarder,
                            discard_tile34=tile34,
                            chi_sequence=opt.sequence,
                        )
                    )

        priority = {RON: 0, KAN_OPEN: 1, PON: 2, CHI_UP: 3, CHI_MID: 3, CHI_DOWN: 3}
        self.pending_claims.sort(
            key=lambda c: (
                priority.get(c.action, 99),
                self._seat_distance(discarder, c.claimant),
            )
        )

        if self.pending_claims:
            self.bus.publish(
                "claims_generated",
                discarder=discarder,
                tile34=tile34,
                claims=[
                    {"claimant": c.claimant, "action": c.action}
                    for c in self.pending_claims
                ],
            )

    @staticmethod
    def _seat_distance(from_seat: int, to_seat: int) -> int:
        """Calculate distance in turn order from one seat to another."""
        d = (to_seat - from_seat) % NUM_SEATS
        return d if d != 0 else NUM_SEATS

    def _apply_reward_shaping_before_discard(self, seat: int) -> float:
        """Compute reward shaping based on shanten and improvement availability."""
        p = self.players[seat]
        sh = p.hand.shanten(self.shanten_calc)

        remaining = self.wall.remaining_tile34_list()
        ava = p.hand.available_improvement_count(self.shanten_calc, remaining)

        if p.state.first_round:
            p.state.first_round = False
            p.state.last_shanten = sh
            p.state.last_available = ava
            return 0.0

        reward_update = 0.0

        if p.state.last_shanten is not None and sh != p.state.last_shanten:
            delta = p.state.last_shanten - sh
            if sh <= p.state.last_shanten:
                reward_update += delta
            else:
                reward_update += delta * 2
            reward_update *= self.reward.reward_weight_shanten

        if (
            (p.state.last_available is not None)
            and (ava != p.state.last_available)
            and (p.state.last_shanten == sh)
        ):
            delta = p.state.last_available - ava
            if ava <= p.state.last_available:
                reward_update += delta
            else:
                reward_update += delta * self.reward.penalty_ava_num

        p.state.last_shanten = sh
        p.state.last_available = ava
        return float(reward_update)

    def _advance_to_next_draw(self) -> None:
        """Advance to next seat and draw a tile, or end game if wall is empty."""
        if self.wall.remaining_live() <= 0:
            self.done = True
            return

        self.seat_now = (self.seat_now + 1) % NUM_SEATS
        draw_tile = self.wall.draw()
        self.players[self.seat_now].draw(draw_tile)

        if self.pending_done and not any(c.action == RON for c in self.pending_claims):
            self.done = True

    def _action_mask(self) -> list[int]:
        """Build a 46-length local action mask for current seat."""
        mask = [0] * ACTIONS_PER_SEAT
        p = self.players[self.seat_now]

        if self.pending_claims:
            offered = [c for c in self.pending_claims if c.claimant == self.seat_now]
            for c in offered:
                mask[c.action] = 1
            mask[PASS] = 1
            return mask

        if self.force_discard_only:
            self._fill_discard_mask(mask, p)
            return mask

        if p.hand.shanten(self.shanten_calc) == -1:
            mask[TSUMO] = 1

        if (
            (not p.state.riichi)
            and (not p.hand.melds)
            and (p.hand.shanten(self.shanten_calc) == 0)
        ):
            mask[RIICHI] = 1

        if any(c == 4 for c in p.hand.as_tile34()):
            mask[KAN_CLOSED] = 1

        self._fill_discard_mask(mask, p)
        return mask

    def _fill_discard_mask(self, mask: list[int], p: MahjongPlayer) -> None:
        """Fill valid discard actions into the mask."""
        if p.state.riichi and p.state.riichi_lock and p.state.last_drawn is not None:
            mask[p.state.last_drawn] = 1
            return

        counts = p.hand.as_tile34()
        for tile34, cnt in enumerate(counts):
            if cnt > 0:
                mask[tile34] = 1

    def _build_obs_and_info(self, reward_update: float) -> Tuple[Dict, Dict]:
        """Build observation and info dictionaries."""
        if not self.done:
            self.history_tokens.append(PLAYER_TOKENS[self.seat_now])
        obs = {
            "tokens": self.history_tokens,
            "is_three": 0,
            "seat": self.seat_now,
            "hand": self.players[self.seat_now].hand.as_tile34(),
        }
        info = {
            "action_mask": self._action_mask(),
            "reward_update": float(reward_update),
        }
        return obs, info

    def _meld_tile_count(self, p: MahjongPlayer) -> int:
        return sum(len(m.tiles_34) for m in p.melds)

    def _total_held_tiles(self, p: MahjongPlayer) -> int:
        return p.hand.total_tiles() + self._meld_tile_count(p)

    def _same_suit_consecutive(self, seq: tuple[int, int, int]) -> bool:
        s = sorted(seq)
        if not (s[0] + 1 == s[1] and s[1] + 1 == s[2]):
            return False
        # 0-8 man, 9-17 pin, 18-26 sou
        if s[2] >= 27:
            return False
        return (s[0] // 9) == (s[2] // 9)

    def assert_integrity(self) -> None:
        """
        Verify tile count integrity across all game components.

        Raises:
            AssertionError: If total tiles != 136 or any tile34 count != 4.
        """
        counts = [0] * 34

        for p in self.players:
            h = p.hand.as_tile34()
            for i, c in enumerate(h):
                counts[i] += c
            for d in p.discards:
                counts[d] += 1
            for m in p.melds:
                for t136 in m.tiles:
                    counts[t136 // 4] += 1

        for t in self.wall.remaining_tile34_list():
            counts[t] += 1
        for t in list(self.wall.rinshan):
            counts[t] += 1
        for t in self.wall.dora_indicators:
            counts[t] += 1

        total = sum(counts)
        if total != 136:
            raise AssertionError(f"total tiles mismatch: {total} != 136")

        bad = [(i, c) for i, c in enumerate(counts) if c != 4]
        if bad:
            raise AssertionError(f"tile count mismatch (tile34, count): {bad}")

        assert 0 <= self.seat_now < NUM_SEATS
        assert 0 <= self.claiming_from < NUM_SEATS
        assert 0 <= self.kan_count <= 4

        # riichi consistency
        for p in self.players:
            if p.state.riichi_lock:
                assert p.state.riichi
                assert p.state.last_drawn is not None
            if p.state.riichi:
                for m in p.melds:
                    if getattr(m, "opened", False):  # opened chi/pon/minkan
                        raise AssertionError("riichi hand has opened meld")

        # claim phase consistency
        if self.pending_claims:
            assert not self.force_discard_only
            head = self.pending_claims[0]
            assert self.seat_now == head.claimant
            assert self.claiming_from == head.from_seat
            discarder = head.from_seat
            tile = head.discard_tile34
            assert self.players[discarder].discards
            assert self.players[discarder].discards[-1] == tile

            for c in self.pending_claims:
                assert c.from_seat == discarder
                assert c.discard_tile34 == tile
                assert c.claimant != discarder
                assert 0 <= c.claimant < NUM_SEATS
                assert 0 <= c.discard_tile34 < 34
                assert 0 <= c.action <= ACTIONS_PER_SEAT
                if c.action in (CHI_UP, CHI_MID, CHI_DOWN):
                    assert c.chi_sequence is not None
                    assert len(c.chi_sequence) == 3
                    assert tile in c.chi_sequence
                    assert self._same_suit_consecutive(c.chi_sequence)
                else:
                    assert c.chi_sequence is None
                if c.action != RON:
                    assert not self.players[c.claimant].state.riichi

            # during claim phase, nobody should have 14 held tiles
            if not self.done:
                for p in self.players:
                    assert self._total_held_tiles(p) == 13

        else:
            # normal turn: exactly seat_now has 14 held tiles
            if not self.done:
                for i, p in enumerate(self.players):
                    want = 14 if i == self.seat_now else 13
                    assert self._total_held_tiles(p) == want


def action_to_str(action: int) -> str:
    if 0 <= action <= 33:
        return f"discards {tile34_to_str(action)}"
    if action in (CHI_UP, CHI_MID, CHI_DOWN):
        return "calls CHI"
    if action == PON:
        return "calls PON"
    if action in (KAN_OPEN, KAN_ADD, KAN_CLOSED):
        return "calls KAN"
    if action == RIICHI:
        return "declares RIICHI"
    if action == RON:
        return "calls RON"
    if action == TSUMO:
        return "calls TSUMO"
    if action == PASS:
        return "PASS"
    return f"action {action}"
